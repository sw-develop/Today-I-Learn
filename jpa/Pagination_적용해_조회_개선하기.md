# Pagination을 적용해 조회 개선하기

<br>

### 간단 패턴화
- 데이터가 많은 경우에 대비해 조회시 Pagination을 필수로 적용한다.
- Pagination에는 오프셋 기반과 커서 기반이 존재하고, 상황에 따라 적절한 방식으로 구현한다.

<br>

## 📌 상황
- 인턴 업무 중 중앙 관리 시스템에 약국명으로 약국 검색 기능을 구현했다.
- 처음에 구현할 때 약국명 검색 결과 반환을 Pagination을 적용하지 않고 해당하는 모든 데이터를 한 번에 반환하도록 코드를 짰다. 더욱이 반환 결과가 팝업창에 띄워지는 형태였고, 결과 데이터가 많은 경우 스크롤을 내려 확인하도록 해서 데이터가 많을 때의 성능 이슈를 생각하지 못했다.
- 로컬에서 테스트할 때는 데이터가 개수가 적어(2만4천건) 성능 이슈를 몰랐지만, 개발 서버에 올린 후 테스트 해보니 아예 값이 반환되지 않았다.
- 이를 통해 데이터가 많은 경우에 대비한 Pagination의 필요성에 대해 절실히 느끼게 되었다.

<br>

## 📌 개선
- JPA에서 제공해주는 Pageable을 사용해 약국 데이터 DB 조회 시 Limit & Offset Pagination을 적용하여 개선하였다. 중앙 관리 시스템에서 사용하는 기능이였기에 스크롤이나 더보기와 같은 커서 기반 페이지네이션 기능은 필요 없어서 오프셋 기반 Pagination 방식을 적용하였다.

```java
//예시 코드
public interface PharmacyRepository extends JpaRepository<Pharmacy, Long> {
	Page<Pharmacy> findByName(String name, Pageable pageable);
}
```

<br>

### ▶️ 성능 개선 이유

Pagination을 적용하면 성능이 개선되는 이유는 다음과 같다.
    
- Limit & Offset에 설정된 값으로 데이터베이스에서 조회할 데이터의 개수가 정해진다.
- 즉, 한번에 10000건을 데이터베이스에서 조회하여 메모리에 올리는 것이 아니라 Limit = 10이라면, 10개씩만 데이터베이스에서 조회하여 메모리에 올린다.

<br>

### ▶️ 성능 개선 확인

개선 후 전체 약국을 조회하여 웹 페이지 결과 반환 성능을 확인해보았다. 
    
- 기존: 무한 로딩
- 개선: 1번의 Pagination 요청마다 250~270ms
    - DB 쿼리는 47ms 정도이다. 프론트 화면 처리 부분에서 추가로 시간이 걸린다.