# 7.2 HTTP + 암호화 + 인증 + 완전성 보호 = HTTPS

- HTTPS에 추가된 기능은
    - 통신 시 암호화, 통신 상대 인증, 데이터 완전성 보호이다.

<br>

## 📌 HTTP에 암호화와 인증과 완전성 보호를 더한 HTTPS

- 기존 HTTP의 문제점을 다시 상기시키자면,
    - HTTP 통신은 암호화되지 않은 평문으로 실시된다.
        - 예시
            - 웹 페이지에서 신용 카드 번호를 입력했을 때 통신이 도청되면 신용 카드 번호를 도청당하게 됨
    - HTTP에는 통신 상대인 서버나 클라이언트를 인증하는 수단이 없다.
    - 수신한 메시지가 도중에 변조되었을 가능성이 있다.
- 이러한 문제를 해결하기 위해서는 암호화, 인증, 완전성 보호 같은 구조를 HTTP에 추가할 필요가 있다. ⇒ 이것을 HTTPS(HTTP Secure)라고 부름

<br>

## 📌 HTTPS는 SSL의 껍질을 덮어쓴 HTTP

- HTTPS는 새로운 애플리케이션 계층의 프로토콜이 아니다. HTTP 통신을 하는 소켓 부분을 SSL이나 TLS 프로토콜로 대체하고 있을 뿐이다.

![image](https://user-images.githubusercontent.com/69254943/203213588-24f214d1-2d2e-4e40-a98f-cdd5c7567d42.png)

- 보통 HTTP는 직접 TCP와 통신하지만 SSL을 사용한 경우에는 HTTP는 SSL과 통신하고, SSL이 TCP와 통신하게 된다.
- SSL을 사용함으로써 HTTP는 HTTP로서 암호화, 증명서, 완전성 보호를 이용할 수 있게 된다.
- SSL은 HTTP와는 독립된 프로토콜로 애플리케이션 계층에서 동작하는 SMTP나 Telnet 등에서도 이용될 수 있다.
    - 널리 사용되고 있는 네트워크 보안 기술임

<br>

## 📌 상호간에 키를 교환하는 공개키 암호화 방식

- SSL에서는 공개키 암호화 방식을 사용한다.

▶️ **공통키 암호의 딜레마**

- 암복호화에 동일한 키를 사용하는 방식을 공통키 암호라고 부른다.
- 공통키 암호화 방식은 상대방에게 키를 넘겨줘야 하는데, 네트워크를 사용해 키를 넘겨줄 때 통신이 도청되어 키가 노출될 수 있다.
- 또한, 받은 키를 안전하게 보관해야 한다.

▶️ **두 개의 키를 사용하는 공개키 암호**

- 위와 같은 공통키 암호에 사용될 키 전달 시 도청 문제를 해결하려고 한 것이 공개키 암호화 방식이다.
- 공개키 암호화 방식은
    - (비밀키, 공개키) 키 페어를 사용한다.

  ![image](https://user-images.githubusercontent.com/69254943/203213611-a67b4f17-c1c9-4e45-972b-27b5bd6c209e.png)

    - 복호화를 위한 비밀키를 통신으로 보낼 필요가 없기 때문에 도청에 의해 키를 빼앗길 가능성이 없다.


▶️ **HTTPS는 하이브리드 암호화 시스템**

- 키를 안전하게 교환할 수만 있다면, 공개키 암호만을 사용하면 되지 않을까?
    - 공개키 암호는 공통키 암호에 비해 처리 속도가 늦는다.
    - 공개키 암호와 공통키 암호 각각의 장점을 살릴 수 있도록 2가지 방식을 조합해서 통신한다.
- HTTPS는
    - 공통키 암호화에 사용할 키를 교환할 때는 공개키 암호를 사용하고,
    - 그 후의 통신에서 메시지를 교환할 때는 공통키 암호를 사용한다.

<br>

## 📌 **공개키가 정확한지 아닌지를 증명하는 증명서 ⇒ 올바른 통신 상대임을 증명**

- 공개키 암호에도 문제점이 존재한다. 공개키가 통신하고자 하는 상대의 것이 맞는지 증명할 필요가 있다.
- 이 문제를 해결하기 위해 인증 기관(CA: Certificate Authority)과 그 기관이 발행하는 공개키 증명서가 이용된다.
    - 인증 기관 : 클라이언트와 서버가 모두 신뢰하는 제3자 기관
- 과정

  ![image](https://user-images.githubusercontent.com/69254943/203213636-4fcc7ad1-2f99-4dda-a76e-45393b980545.png)

    - 인증기관의 공개키는 안전하게 클라이언트에게 전달되어야 하는데, 통신중에는 어떤 방법을 사용하더라도 안전하게 전달하는 것은 어려움
    - 많은 브라우저가 주요 인증기관의 공개키를 사전에 내장하고 있음

<br>

## 📌 안전한 통신을 하는 HTTPS의 구조

![image](https://user-images.githubusercontent.com/69254943/203213663-2eb5c72b-0a70-4491-90e9-49940ce5726c.png)

1) 클라이언트가 Client Hello 메시지를 보내면서 SSL 통신을 시작한다.

- 메시지에 클라이언트가 제공하는 SSL의 버전을 지정하고,
- Cipher Suite로 불리는 리스트(사용하는 암호화의 알고리즘이나 키 사이즈 등) 등이 포함되어 있음

2) 서버가 SSL 통신이 가능한 경우에는 Server Hello 메시지로 응답한다.

- SSL 버전과 Cipher Suite를 포함함
- 서버의 Cipher Suite 내용은 클라이언트로부터 받은 Cipher Suite 내용에서 선택된 것임

3) 서버가 Certificate 메시지를 전송한다.

- 메시지에는 공개키 증명서가 포함되어 있음

4) 서버가 Server Hello Done 메시지를 보내 최초의 SSL negotiation 부분이 끝났음을 통지한다.

5) SSL의 최초 negotiationdl 종료되면, 클라이언트가 Client Key Exchange 메시지로 응답한다.

- 메시지에는 통신을 암호화하는데 사용하는 Pre-Master secret이 포함되어 있음 (대칭키 암호화 통신을 위한)
- 이 메시지는 3)의 공개키 증명서에서 꺼낸 Server의 공개키로 암호화되어 있음

6) 클라이언트가 Change Cipher Spec 메시지를 전송한다.

- 이 메시지 이후의 통신은 암호키를 사용해 진행한다는 것을 나타냄 ⇒ 이제 대칭키 암호화 통신을 하겠다!

7) 클라이언트가 Finished 메시지를 전송한다.

- 이 메시지는 접속 전체의 체크 값을 포함하고 있음
- negotiation 성공 여부는 서버가 이 메시지를 대칭키를 가지고 올바르게 복호화할 수 있는지에 따라 결정됨

8) 서버에서도 마찬가지로 Change Cipher Spec 메시지를 전송한다. ⇒ 이제 대칭키 암호화 통신을 하겠다!

9) Finished 메시지를 전송한다.

10) 서버와 클라이언트의 Finished 메시지 교환이 완료되면 SSL에 의해서 접속은 확립된다.

- 통신은 SSL에 의해 보호됨 ⇒ 데이터 교환 시 대칭키 암호화 사용됨
- 이제부터 애플리케이션 계층의 프로토콜에 의해 통신을 함 ⇒ 즉, HTTP 요청을 보냄

11) 애플리케이션 계층의 프로토콜에 의해 통신을 함 ⇒ 즉, HTTP 응답을 보냄

12) 마지막에 클라이언트가 접속을 끊는다.

- 접속을 끊을 경우 close_notify 메시지를 전송함
- 이후 TCP 연결을 종료함 ⇒ 주의할 것은 TCP Layer와 SSL Layer는 분리되어 있기 때문에 각각의 통신 구조만 생각하면 됨, 단지 SSL 통신이 끝나면 서버와 클라이언트간 통신이 더이상 이루어지지 않는 것이므로, TCP 연결도 종료되어야 하는 것임

<br>

**▶️ 추가적으로**

- 애플리케이션 계층의 데이터 송신할 때(HTTP 요청, 응답 보낼 때) MAC(Message Authentication Code)이라고 부르는 메시지 다이제스트를 덧붙일 수 있다.
- 이를 통해 데이터의 변조를 감지해 완전성 보호를 실현한다.

![image](https://user-images.githubusercontent.com/69254943/203213687-ca985419-9d46-4924-bd8a-66402d926f00.png)

**▶️ SSL과 TLS**

- HTTPS에서는 SSL(Secure Socket Layer)과 TLS(Transport Layer Security)라는 2개의 프로토콜을 사용한다.
- TLS는 SSL을 바탕으로 한 프로토콜이지만, 이 프로토콜을 총칭해서 SSL이라고 부르기도 한다.
- 현재는 SSL3.0, TLS1.0이 주류이다.

**▶️ SSL은 느리다?**

- SSL 통신이 지연되는 이유는 2가지가 있다.

    1) 통신 속도가 떨어지는 것

    - TCP 접속과 HTTP의 요청, 응답 이외에 SSL에 필요한 통신이 추가됨

    2) CPU나 메모리 등의 리소스를 다량으로 소비하여 처리가 느려지는 것

    - SSL은 반드시 암호화 처리를 하므로, 암복호화를 위한 계산 필요함

- 개선하려면?
    - SSL 엑셀레이터라는 하드웨어를 사용해 개선 가능하다.
        - SSL을 처리하기 위한 전용 하드웨어로 소프트웨어로 SSL을 처리할 때보다 더 빠른 계산 가능함
        - SSL의 처리만 SSL 엑셀레이터에 맡겨 부하를 분산시킴